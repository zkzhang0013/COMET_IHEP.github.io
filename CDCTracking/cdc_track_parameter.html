<!DOCTYPE html>
<html>

<head>
    <title>COMET CDC Track Parameter</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #1a1a2e;
            font-family: Arial, sans-serif;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
            max-width: 300px;
        }

        .control-group {
            margin: 10px 0;
        }

        button {
            margin: 5px;
            padding: 8px 15px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #1976d2;
        }

        #status {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
        }

        .param-control {
            margin: 8px 0;
        }

        .param-control label {
            display: inline-block;
            width: 80px;
            color: #4fc3f7;
        }

        .param-control input {
            width: 120px;
        }
    </style>
</head>

<body>
    <div id="controls">
        <h3>COMET CDC Track parameterization</h3>

        <div class="control-group">
            <button id="reset-view">Reset View</button>
            <button id="reset-all">Reset All</button>
        </div>

        <div class="control-group">
            <div class="param-control">
                <label>φ :</label>
                <input type="range" id="phi-slider" min="0" max="360" step="1" value="45">
                <span id="phi-value">45°</span>
            </div>

            <div class="param-control">
                <label>κ=q/pt:</label>
                <input type="range" id="kappa-slider" min="0.1" max="2" step="0.1" value="0.8">
                <span id="kappa-value">0.4</span>
            </div>

            <div class="param-control">
                <label>ψ (py,px):</label>
                <input type="range" id="psi-slider" min="0" max="90" step="1" value="30">
                <span id="psi-value">30°</span>
            </div>

            <div class="param-control">
                <label>λ=pz/pt:</label>
                <input type="range" id="lambda-slider" min="-2" max="2" step="0.1" value="0.5">
                <span id="lambda-value">0.5</span>
            </div>

            <div class="param-control">
                <label>z0:</label>
                <input type="range" id="z0-slider" min="-4" max="4" step="0.1" value="0">
                <span id="z0-value">0.0</span>
            </div>

            <div class="control-group">
                <div>Mouse Left Button: Rotate View</div>
                <div>Mouse Right Button: Pan View</div>
                <div>Mouse Wheel: Zoom In/Out</div>
            </div>

            <div> Author: Yao Zhang (zhangyao@ihep.ac.cn)</div>
        </div>
        <div class="control-group">
            <label style="color:#4fc3f7; display:inline-block; width:80px;">XY Size:</label>
            <input type="range" id="xy-size-slider" min="120" max="800" step="10" value="340" style="vertical-align:middle;">
            <span id="xy-size-value" style="color:#fff; margin-left:8px;">340px</span>
        </div>
        <div class="control-group">
            <label style="color:#4fc3f7; display:inline-block; width:80px;">XY Elements:</label>
            <div style="display:inline-block; vertical-align:middle;">
                <label style="color:#fff; margin-right:6px;"><input type="checkbox" id="chk-track" checked>Track</label>
                <label style="color:#fff; margin-right:6px;"><input type="checkbox" id="chk-momentum" checked>p</label>
                <label style="color:#fff; margin-right:6px;"><input type="checkbox" id="chk-phi" checked>φ</label>
                <label style="color:#fff; margin-right:6px;"><input type="checkbox" id="chk-psi" checked>ψ</label>
                <label style="color:#fff; margin-right:6px;"><input type="checkbox" id="chk-labels" checked>Labels</label>
            </div>
            <button id="xy-reset-btn" style="margin-left:8px;">Reset XY</button>
        </div>
    </div>
     <canvas id="xyCanvas" width="340" height="340" style="position:absolute; bottom:20px; right:20px;
         border:1px solid #4fc3f7; background:#000a; width:340px; height:340px;">
     </canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        LINEWIDTH = 5;
        const COLOR_SOFT_RED = 0xE15759;
        const COLOR_WARM_ORANGE = 0xF28E2C;
        const COLOR_PINE_GREEN = 0x59A14F;
        const COLOR_LAKE_CYAN = 0x76B7B2;
        const COLOR_MIST_BLUE = 0x4E79A7;
        const COLOR_ASH_PURPLE = 0xB07AA1;
        const COLOR_NUDE_PINK = 0xFF9DA7;
        const COLOR_SAND_BROWN = 0x8C564B;
        const COLOR_BLACK = 0x000000;
        const COLOR_WHITE = 0xFFFFFF;
        const COLOR_GRAY = 0x888888;

        // 场景
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // 相机
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(10, 8, 10);
        camera.lookAt(0, 0, 0);

        // 轨道控制器
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = true;
        controls.minDistance = 3;
        controls.maxDistance = 30;

        // 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 15);
        scene.add(directionalLight);

        // =================== 物理参数 ===================
        let params = {
            q: -1,          // 电荷 q
            kappa: 0.4,      // curvature κ = q/pt
            psi: 30,        // ψ angle that px,py make with X axis in XY plane
            phi0: 45,        // φ angle that point P makes with X axis in XY plane
            lambda: 0.5,    // λ = pz/pt
            z0: 0,        // initial z position
            cylinder_radius: 5,      // reference cylinder radius of the CDC
            cylinder_length: 8       // reference cylinder length
        };

        // =================== 创建几何元素 ===================

        // 1. 创建半透明蓝色圆柱（探测器几何）
        function createDetectorCylinder() {
            const geometry = new THREE.CylinderGeometry(
                params.cylinder_radius, params.cylinder_radius, params.cylinder_length, 64, 1, true
            );
            geometry.rotateX(Math.PI / 2);

            const material = new THREE.MeshPhongMaterial({
                color: COLOR_LAKE_CYAN,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });

            const cylinder = new THREE.Mesh(geometry, material);
            cylinder.name = "DetectorCylinder";

            return cylinder;
        }

        // 2. 创建点P（蓝色小球）
        function createPointP() {
            const geometry = new THREE.SphereGeometry(0.05, 6, 6);
            const material = new THREE.MeshPhongMaterial({
                color: COLOR_MIST_BLUE,
                shininess: 100
            });

            const sphere = new THREE.Mesh(geometry, material);
            sphere.name = "PointP";

            return sphere;
        }

        // 3. 创建径迹- 根据新的螺旋线公式
        function createTrack() {
            // 计算点P的位置（圆柱表面）
            const phiRad = THREE.MathUtils.degToRad(params.phi0);

            // 点P在圆柱表面
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = params.z0; // 在圆柱中间高度

            // 计算螺旋径迹参数
            const R = 1 / (2 * Math.abs(params.kappa)); // 曲率半径
            const points = [];
            const numPoints = 200;

            // ψ角是px,py在XY平面内的夹角
            const psiRad = THREE.MathUtils.degToRad(params.psi);

            // 计算初始动量方向（在XY平面内）
            // px方向由ψ决定
            const px = Math.cos(psiRad);
            const py = Math.sin(psiRad);
            const pz = params.lambda * Math.sqrt(px * px + py * py);

            // 归一化XY平面内的动量
            const pT = Math.sqrt(px * px + py * py); // 横向动量大小

            for (let i = 0; i <= numPoints; i++) {
                const t = (i / numPoints) * 4 * Math.PI; // 增加t范围以获得更长的径迹
                const k = Math.sign(params.kappa);

                // 根据曲率计算旋转角度
                const theta = k * t;

                // 螺旋线方程
                const x = x0 + (Math.sin(theta + psiRad) - Math.sin(psiRad)) * R / pT;
                const y = y0 + (Math.cos(psiRad) - Math.cos(theta + psiRad)) * R / pT;
                const z = zP + params.lambda * theta * R;

                points.push(new THREE.Vector3(x, y, z));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: COLOR_SOFT_RED,
                linewidth: LINEWIDTH
            });

            return new THREE.Line(geometry, material);
        }

        // 4. 创建φ角 - 点P在圆柱上的位置
        function createPhiArc() {
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const points = [];
            const segments = 30;

            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * phiRad;
                const radius = params.cylinder_radius + 0.01; // 稍微大于圆柱半径
                points.push(new THREE.Vector3(
                    radius * Math.cos(angle),
                    radius * Math.sin(angle),
                    0.1 // 稍微抬高避免Z-fighting
                ));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: COLOR_PINE_GREEN,
                linewidth: LINEWIDTH
            });

            return new THREE.Line(geometry, material);
        }

        // 5. 创建ψ角- px,py夹角
        function createPsiArc() {
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const psiRad = THREE.MathUtils.degToRad(params.psi);
            const points = [];
            const segments = 30;

            // 点P的位置
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = 0;

            // 在XY平面内绘制ψ角
            // ψ角是px,py的夹角，所以在XY平面内
            const arcRadius = 1.5;

            // 起点：径向方向
            const startAngle = phiRad;

            // 终点：动量方向
            const endAngle = psiRad;

            for (let i = 0; i <= segments; i++) {
                const t = (i / segments) * psiRad;

                // 从X轴开始，旋转ψ角
                const angle = t;
                const x = arcRadius * Math.cos(angle);
                const y = arcRadius * Math.sin(angle);

                points.push(new THREE.Vector3(
                    x0 + x,
                    y0 + y,
                    zP + 0.1 // 稍微抬高
                ));
            }

            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: COLOR_SOFT_RED,
                linewidth: 2
            });

            return new THREE.Line(geometry, material);
        }

        function createLambdaArc(pz,pt) {
            const points = [];
            const segments = 30;

            // 点P的位置
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            //const pt = params.kappa !== 0 ? 1 / Math.abs(params.kappa) : 10; // 避免除以零
            //const x = pt * Math.cos(THREE.MathUtils.degToRad(params.psi));
            //const y = pt * Math.sing(THREE.MathUtils.degToRad(params.psi));
            //const z = params.z0;

            //// 在Z方向绘制λ角
            //const arcRadius = params.lambda;

            //for (let i = 0; i <= segments; i++) {
            //    const t = (i / segments) * Math.atan(params.lambda);

            //    // 从XY平面开始，旋转λ角
            //    const x = arcRadius * Math.cos(t);
            //    const z = arcRadius * Math.sin(t);

            //    points.push(new THREE.Vector3(
            //        x0 + x,
            //        y0,
            //        zP + z + 0.1 // 稍微抬高
            //    ));
            //}

            //const geometry = new THREE.BufferGeometry().setFromPoints(points);
            //const material = new THREE.LineBasicMaterial({
            //    color: COLOR_NUDE_PINK,
            //    linewidth: 2
            //});

            //return new THREE.Line(geometry, material);
        }

        // 6. 创建Y平面（灰色半透明平面）
        function createYPlane() {
            const geometry = new THREE.PlaneGeometry(15, 15);
            const material = new THREE.MeshPhongMaterial({
                color: COLOR_GRAY,
                transparent: true,
                opacity: 0.1,
                side: THREE.DoubleSide
            });

            const plane = new THREE.Mesh(geometry, material);
            plane.name = "YPlane";
            plane.rotation.x = Math.PI / 2; // 垂直于Y轴

            return plane;
        }

        // createLabel: 可选传入 scale 参数用于在小窗中按像素宽度自适应标签大小
        // scale: 如果为 null 则使用默认 (1.5, 0.75)，否则设置为 (scale, scale*0.5)
        function createLabel(text, position, color = 0xffffff, scale = null) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');

            // 设置合适的画布大小
            canvas.width = 256;
            canvas.height = 128;

            // 清空画布
            context.clearRect(0, 0, canvas.width, canvas.height);

            // 配置文字样式
            context.font = 'Bold 64px Arial';
            context.fillStyle = '#' + color.toString(16).padStart(6, '0'); // 转换 hex 为 CSS 颜色
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            // 绘制文字（居中）
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            // 创建纹理并标记需要更新
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;

            // 创建 sprite
            const material = new THREE.SpriteMaterial({
                map: texture,
                transparent: true
            });
            const sprite = new THREE.Sprite(material);

            // 调整缩放：保持默认纵横比 (2:1)
            if (scale === null) {
                sprite.scale.set(1.5, 0.75, 1);
            } else {
                sprite.scale.set(scale, scale * 0.5, 1);
            }
            sprite.position.copy(position);

            return sprite;
        }


        // 7. 创建文字标注
        function createTextLabels() {
            const group = new THREE.Group();

            // 点P的位置
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = 0;

            return group;
        }

        // 8. 创建坐标轴（红绿蓝）
        function createCoordinateAxes() {
            const group = new THREE.Group();
            const axisLength = 8;
            const headLength = 0.4;
            const headWidth = 0.2;

            // X轴（红色箭头）
            const xDir = new THREE.Vector3(1, 0, 0);
            const xOrigin = new THREE.Vector3(0, 0, 0);
            const xArrow = new THREE.ArrowHelper(xDir, xOrigin, axisLength, COLOR_SOFT_RED, headLength, headWidth);
            group.add(xArrow);

            // Y轴（绿色箭头）
            const yDir = new THREE.Vector3(0, 1, 0);
            const yOrigin = new THREE.Vector3(0, 0, 0);
            const yArrow = new THREE.ArrowHelper(yDir, yOrigin, axisLength, COLOR_PINE_GREEN, headLength, headWidth);
            group.add(yArrow);

            // Z轴（蓝色箭头）
            const zDir = new THREE.Vector3(0, 0, 1);
            const zOrigin = new THREE.Vector3(0, 0, 0);
            const zArrow = new THREE.ArrowHelper(zDir, zOrigin, axisLength, COLOR_MIST_BLUE, headLength, headWidth);
            group.add(zArrow);

            // add axis labels
            group.add(createLabel('X', new THREE.Vector3(axisLength + 0.2, 0, 0), COLOR_SOFT_RED));
            group.add(createLabel('Y', new THREE.Vector3(0.5, axisLength - 0.2, 0), COLOR_PINE_GREEN));
            group.add(createLabel('Z', new THREE.Vector3(0, 0, axisLength + 0.2), COLOR_MIST_BLUE));
            group.add(createLabel('O', new THREE.Vector3(0.5, 0.5, 0), COLOR_GRAY));
            group.add(createLabel("XZ-Plane", new THREE.Vector3(8, 2, 0), x_plane_color = COLOR_GRAY));


            return group;
        }

        // 9. 创建动量方向指示器
        function createMomentumIndicator() {
            const group = new THREE.Group();

            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const psiRad = THREE.MathUtils.degToRad(params.psi);

            // 点P的位置（3D圆柱坐标）
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const zP = params.z0;

            //pxyz,pt
            const pt = params.kappa !== 0 ? 1 / Math.abs(params.kappa) : 10; // 避免除以零
            const p = Math.sqrt(pt * pt + (params.lambda * pt) * (params.lambda * pt));
            const px = pt * Math.cos(psiRad);
            const py = pt * Math.sin(psiRad);
            const pz = params.lambda * pt;

            // 动量方向向量（ψ相对于径向方向）
            const momentumDir = new THREE.Vector3(
                Math.cos(psiRad),
                Math.sin(psiRad),
                params.lambda
            ).normalize();
            const pxDir = new THREE.Vector3(
                px,
                0,
                0
            ).normalize();
            const pyDir = new THREE.Vector3(
                0,
                py,
                0
            ).normalize();
            const pzDir = new THREE.Vector3(
                0,
                0,
                pz
            ).normalize();

            const momentumLength = p;
            const arrowOrigin = new THREE.Vector3(x0, y0, zP);

            //  使用 ArrowHelper 自动处理3D方向
            const arrowHelper = new THREE.ArrowHelper(
                momentumDir,           // 方向（已归一化）
                arrowOrigin,           // 起点
                momentumLength,        // 长度
                COLOR_WARM_ORANGE,              // 颜色
                momentumLength * 0.1,  // 箭头长度
                momentumLength * 0.05  // 箭头宽度
            );
            const pxArrowHelper = new THREE.ArrowHelper(
                pxDir,           // 方向（已归一化）
                arrowOrigin,           // 起点
                px, // 长度
                COLOR_SOFT_RED,              // 颜色
                0.2,  // 箭头长度
                0.2  // 箭头宽度
            );
            const pyArrowHelper = new THREE.ArrowHelper(
                pyDir,           // 方向（已归一化）
                arrowOrigin,           // 起点
                py,// 长度
                COLOR_PINE_GREEN,              // 颜色
                0.2,  // 箭头长度
                0.2  // 箭头宽度
            );
            const pzArrowHelper = new THREE.ArrowHelper(
                pzDir,           // 方向（已归一化）
                arrowOrigin,           // 起点
                pz, // 长度
                COLOR_MIST_BLUE,              // 颜色
                0.2,  // 箭头长度
                0.2  // 箭头宽度
            );
            const ptArrowHelper = new THREE.ArrowHelper(
                new THREE.Vector3(
                    Math.cos(psiRad),
                    Math.sin(psiRad),
                    0
                ).normalize(),           // 方向（已归一化）
                arrowOrigin,           // 起点
                pt, // 长度
                COLOR_LAKE_CYAN,              // 颜色
                0.2,  // 箭头长度
                0.2  // 箭头宽度
            );
            // a dashed line from point of pt to point of p
            const pz2ptLine = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(
                    x0 + px,
                    y0 + py,
                    zP + 0
                ),
                new THREE.Vector3(
                    x0,
                    y0,
                    zP + pz,
                )
                ]),
                new THREE.LineDashedMaterial({
                    color: COLOR_LAKE_CYAN,
                    dashSize: 1,
                    gapSize: 2,
                    linewidth: LINEWIDTH
                })
            );
            group.add(arrowHelper);
            group.add(pxArrowHelper);
            group.add(pyArrowHelper);
            group.add(pzArrowHelper);
            group.add(ptArrowHelper);
            group.add(pz2ptLine);


            // 添加各个标签
            group.add(createLabel("p", new THREE.Vector3(
                x0 + momentumDir.x * (momentumLength + 0.5),
                y0 + momentumDir.y * (momentumLength + 0.5),
                zP + momentumDir.z * (momentumLength + 0.5)
            ), COLOR_WARM_ORANGE));
            group.add(createLabel("φ=" + params.phi0 + "°",
                new THREE.Vector3(
                    (params.cylinder_radius + 0.6) * Math.cos(phiRad / 2),
                    (params.cylinder_radius + 0.6) * Math.sin(phiRad / 2),
                    0.2
                ), COLOR_PINE_GREEN));
            group.add(createLabel("ψ=" + params.psi + "°",
                new THREE.Vector3(
                    x0 + 2.1 * Math.cos(psiRad / 2),
                    y0 + 2.1 * Math.sin(psiRad / 2),
                    0.2
                ), COLOR_SOFT_RED));
            group.add(createLabel("λ=" + params.lambda.toFixed(1), new THREE.Vector3(
                x0 + (Math.cos(psiRad)) * (pt + 0.8),
                y0 + (Math.sin(psiRad)) * (pt + 0.8),
                zP - 0.5
            ), COLOR_LAKE_CYAN));

            group.add(createLabel("z0=" + params.z0.toFixed(1), new THREE.Vector3(
                x0 + 1.,
                y0 - 0.2,
                zP
            ), COLOR_MIST_BLUE));
            group.add(createLabel("px", new THREE.Vector3(
                x0 + pxDir.x * (px + 0.5),
                y0 + pxDir.y * (px + 0.5),
                zP + pxDir.z * (px + 0.5)
            ), COLOR_SOFT_RED));
            group.add(createLabel("py", new THREE.Vector3(
                x0 + pyDir.x * (py + 0.5),
                y0 + pyDir.y * (py + 0.5),
                zP + pyDir.z * (py + 0.5)
            ), COLOR_PINE_GREEN));
            group.add(createLabel("pz", new THREE.Vector3(
                x0 + pzDir.x * (pz + 0.5) + 0.5,
                y0 + pzDir.y * (pz + 0.5),
                zP + pzDir.z * (pz + 0.5)
            ), COLOR_MIST_BLUE));
            group.add(createLabel("pt", new THREE.Vector3(
                x0 + (Math.cos(psiRad)) * (pt + 0.5),
                y0 + (Math.sin(psiRad)) * (pt + 0.5),
                zP + 0.2
            ), COLOR_LAKE_CYAN));


            return group;
        }

        // =================== 初始化场景 ===================
        let detectorCylinder, pointP, track, phiArc, psiArc, lambdaArc, yPlane, labels, axes, momentumIndicator;

        function initScene() {
            // 清除旧元素
            if (detectorCylinder) scene.remove(detectorCylinder);
            if (pointP) scene.remove(pointP);
            if (track) scene.remove(track);
            if (phiArc) scene.remove(phiArc);
            if (psiArc) scene.remove(psiArc);
            if (lambdaArc) scene.remove(lambdaArc);
            if (yPlane) scene.remove(yPlane);
            if (labels) scene.remove(labels);
            if (axes) scene.remove(axes);
            if (momentumIndicator) scene.remove(momentumIndicator);

            // 创建新元素
            detectorCylinder = createDetectorCylinder();
            pointP = createPointP();
            track = createTrack();
            phiArc = createPhiArc();
            psiArc = createPsiArc();
            lambdaArc = createLambdaArc();
            yPlane = createYPlane();
            labels = createTextLabels();
            axes = createCoordinateAxes();
            momentumIndicator = createMomentumIndicator();

            // 计算点P的位置并设置
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            pointP.position.set(x0, y0, 0);

            // 添加到场景
            scene.add(detectorCylinder);
            scene.add(pointP);
            scene.add(track);
            scene.add(phiArc);
            scene.add(psiArc);
            scene.add(lambdaArc);
            scene.add(yPlane);
            scene.add(labels);
            scene.add(axes);
            scene.add(momentumIndicator);
        }

        // =================== UI控制 ===================

        // 初始化UI值显示
        document.getElementById('kappa-value').textContent = params.kappa.toFixed(1);
        document.getElementById('psi-value').textContent = params.psi + '°';
        document.getElementById('phi-value').textContent = params.phi0 + '°';
        document.getElementById('lambda-value').textContent = params.lambda.toFixed(1);
        document.getElementById('z0-value').textContent = params.z0.toFixed(1);

        // 滑块控制
        document.getElementById('kappa-slider').addEventListener('input', (e) => {
            params.kappa = parseFloat(e.target.value);
            document.getElementById('kappa-value').textContent = params.kappa.toFixed(1);
            initScene();
        });

        document.getElementById('psi-slider').addEventListener('input', (e) => {
            params.psi = parseInt(e.target.value);
            document.getElementById('psi-value').textContent = params.psi + '°';
            initScene();
        });

        document.getElementById('phi-slider').addEventListener('input', (e) => {
            params.phi0 = parseInt(e.target.value);
            document.getElementById('phi-value').textContent = params.phi0 + '°';
            initScene();
        });

        document.getElementById('lambda-slider').addEventListener('input', (e) => {
            params.lambda = parseFloat(e.target.value);
            document.getElementById('lambda-value').textContent = params.lambda.toFixed(1);
            initScene();
        });
        document.getElementById('z0-slider').addEventListener('input', (e) => {
            params.z0 = parseFloat(e.target.value);
            z0 = params.z0;
            document.getElementById('z0-value').textContent = params.z0.toFixed(1);
            initScene();
        });

        // 按钮控制
        document.getElementById('reset-view').addEventListener('click', () => {
            controls.reset();
            updateStatus('View reset');
        });

        document.getElementById('reset-all').addEventListener('click', () => {
            params.kappa = 0.4;
            params.psi = 30;
            params.phi0 = 45;
            params.lambda = 0.5;
            params.z0 = 0;

            document.getElementById('kappa-slider').value = params.kappa;
            document.getElementById('psi-slider').value = params.psi;
            document.getElementById('phi-slider').value = params.phi0;
            document.getElementById('lambda-slider').value = params.lambda;

            document.getElementById('kappa-value').textContent = params.kappa.toFixed(1);
            document.getElementById('psi-value').textContent = params.psi + '°';
            document.getElementById('phi-value').textContent = params.phi0 + '°';
            document.getElementById('lambda-value').textContent = params.lambda.toFixed(1);
            document.getElementById('z0-value').textContent = params.z0.toFixed(1);

            initScene();
            updateStatus('All parameters reset');
        });

        // =================== 辅助函数 ===================
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // =================== 初始化并运行动画 ===================
        initScene();

        // -------- 投影小窗专用 Three 对象 --------
        const xyScene = new THREE.Scene();
        const xyCam = new THREE.OrthographicCamera(
            -6, 6,   // left, right
            6, -6,  // top, bottom
            -1, 20);
        const xyCanvas = document.getElementById('xyCanvas');
        const xyRenderer = new THREE.WebGLRenderer({
            canvas: xyCanvas,
            alpha: true
        });
        // responsive renderer size (initially matches canvas CSS size)
        function updateXYRendererSize() {
            const cssW = xyCanvas.clientWidth || xyCanvas.width || 340;
            const cssH = xyCanvas.clientHeight || xyCanvas.height || 340;
            // set device pixel ratio aware size for crisp rendering
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            xyRenderer.setPixelRatio(dpr);
            xyRenderer.setSize(Math.floor(cssW), Math.floor(cssH), false);
            // update camera aspect/viewport if needed (not necessary for orthographic, but update projection)
            xyCam.updateProjectionMatrix();
        }
        updateXYRendererSize();

        // bind UI slider if present
        const xySizeSlider = document.getElementById('xy-size-slider');
        const xySizeValue = document.getElementById('xy-size-value');
        if (xySizeSlider && xyCanvas) {
            xySizeSlider.addEventListener('input', (e) => {
                const v = parseInt(e.target.value, 10);
                xySizeValue.textContent = v + 'px';
                xyCanvas.style.width = v + 'px';
                xyCanvas.style.height = v + 'px';
                updateXYRendererSize();
            });
        }

        // element visibility controls
        const chkTrack = document.getElementById('chk-track');
        const chkMomentum = document.getElementById('chk-momentum');
        const chkPhi = document.getElementById('chk-phi');
        const chkPsi = document.getElementById('chk-psi');
        const chkLabels = document.getElementById('chk-labels');

        // reset XY size button
        const xyResetBtn = document.getElementById('xy-reset-btn');
        if (xyResetBtn) {
            xyResetBtn.addEventListener('click', () => {
                const def = 340;
                if (xySizeSlider) {
                    xySizeSlider.value = def;
                    xySizeValue.textContent = def + 'px';
                }
                xyCanvas.style.width = def + 'px';
                xyCanvas.style.height = def + 'px';
                updateXYRendererSize();
                updateStatus('XY size reset');
            });
        }

        // 纯色背景
        xyScene.background = new THREE.Color(COLOR_WHITE);

        // labels group for small window
        const xyLabelsGroup = new THREE.Group();
        xyScene.add(xyLabelsGroup);
        // axes group for small window
        const xyAxesGroup = new THREE.Group();
        xyScene.add(xyAxesGroup);

        function updateXYCameraBounds() {
            // choose extent to cover detector and some padding
            const extent = Math.max(Math.abs(params.cylinder_radius) + 3, 6);
            xyCam.left = -extent;
            xyCam.right = extent;
            xyCam.top = extent;
            xyCam.bottom = -extent;
            xyCam.updateProjectionMatrix();
        }

        function buildXYProjections() {
            // ensure camera covers scene
            updateXYCameraBounds();

            // 清旧对象
            [xyTrack, xyPArr, xyPhiArc, xyPsiArc].forEach(o => o && xyScene.remove(o));
            while (xyLabelsGroup.children.length) xyLabelsGroup.remove(xyLabelsGroup.children[0]);
            while (xyAxesGroup.children.length) xyAxesGroup.remove(xyAxesGroup.children[0]);

            /* 1. 径迹投影（只取 x,y） */
            const pts2D = [];
            const num = 200;
            for (let i = 0; i <= num; i++) {
                const t = (i / num) * 4 * Math.PI;
                const k = Math.sign(params.kappa);
                const theta = k * t;
                const R = 1 / (2 * Math.abs(params.kappa));
                const psiRad = THREE.MathUtils.degToRad(params.psi);
                const phiRad = THREE.MathUtils.degToRad(params.phi0);
                const x0 = params.cylinder_radius * Math.cos(phiRad);
                const y0 = params.cylinder_radius * Math.sin(phiRad);
                const pT = 1; // 归一化
                const x = x0 + (Math.sin(theta + psiRad) - Math.sin(psiRad)) * R / pT;
                const y = y0 + (Math.cos(psiRad) - Math.cos(theta + psiRad)) * R / pT;
                pts2D.push(new THREE.Vector3(x, y, 0)); // z=0 放在 XY 平面
            }
            xyTrack = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(pts2D),
                new THREE.LineBasicMaterial({ color: COLOR_SOFT_RED, linewidth: 2 }));
            if (!chkTrack || chkTrack.checked) xyScene.add(xyTrack);

            /* 2. 动量箭头投影 */
            const phiRad = THREE.MathUtils.degToRad(params.phi0);
            const psiRad = THREE.MathUtils.degToRad(params.psi);
            const x0 = params.cylinder_radius * Math.cos(phiRad);
            const y0 = params.cylinder_radius * Math.sin(phiRad);
            const dir2D = new THREE.Vector3(Math.cos(psiRad), Math.sin(psiRad), 0);
            xyPArr = new THREE.ArrowHelper(
                dir2D, new THREE.Vector3(x0, y0, 0),
                2.5, COLOR_WARM_ORANGE, 0.4, 0.2);
            if (!chkMomentum || chkMomentum.checked) xyScene.add(xyPArr);

            /* 3. φ 弧投影 */
            const phiPts = [];
            for (let i = 0; i <= 30; i++) {
                const a = (i / 30) * phiRad;
                phiPts.push(new THREE.Vector3(
                    (params.cylinder_radius + 0.1) * Math.cos(a),
                    (params.cylinder_radius + 0.1) * Math.sin(a), 0));
            }
            xyPhiArc = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(phiPts),
                new THREE.LineBasicMaterial({ color: COLOR_PINE_GREEN }));
            if (!chkPhi || chkPhi.checked) xyScene.add(xyPhiArc);

            /* 4. ψ 弧投影 */
            const psiPts = [];
            const arcR = 1.5;
            for (let i = 0; i <= 20; i++) {
                const a = (i / 20) * psiRad;
                psiPts.push(new THREE.Vector3(
                    x0 + arcR * Math.cos(a),
                    y0 + arcR * Math.sin(a), 0));
            }
            xyPsiArc = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(psiPts),
                new THREE.LineBasicMaterial({ color: COLOR_SAND_BROWN }));
            if (!chkPsi || chkPsi.checked) xyScene.add(xyPsiArc);

            // ----- 添加 XY 轴（带箭头与标签） -----
            try {
                const extent = Math.max(Math.abs(params.cylinder_radius) + 3, 6);
                // compute label scale based on current xy canvas width (base: 340px => scale 1.5)
                const baseCanvas = 340;
                const canvasW = xyCanvas ? (xyCanvas.clientWidth || xyCanvas.width || baseCanvas) : baseCanvas;
                const xyScale = 1.5 * (canvasW / baseCanvas);

                // X axis
                const xArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), extent - 1, COLOR_SOFT_RED, 0.4, 0.2);
                xyAxesGroup.add(xArrow);
                xyAxesGroup.add(createLabel('X', new THREE.Vector3(extent - 0.6, 0.25, 0), COLOR_SOFT_RED, xyScale));

                // Y axis
                const yArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), extent - 1, COLOR_PINE_GREEN, 0.4, 0.2);
                xyAxesGroup.add(yArrow);
                xyAxesGroup.add(createLabel('Y', new THREE.Vector3(0.25, extent - 0.6, 0), COLOR_PINE_GREEN, xyScale));
            } catch (e) {
                console.warn('xy axes failed', e);
            }

            // ----- 添加标签 (P, p, φ, ψ, track) -----
            try {
                // point P label
                const phiRad = THREE.MathUtils.degToRad(params.phi0);
                const x0 = params.cylinder_radius * Math.cos(phiRad);
                const y0 = params.cylinder_radius * Math.sin(phiRad);
                if (!chkLabels || chkLabels.checked) xyLabelsGroup.add(createLabel('P', new THREE.Vector3(x0 + 0.12, y0 + 0.12, 0), COLOR_MIST_BLUE, xyScale));

                // momentum label near arrow tip
                const psiRad = THREE.MathUtils.degToRad(params.psi);
                const dir2D = new THREE.Vector3(Math.cos(psiRad), Math.sin(psiRad), 0);
                if (!chkLabels || chkLabels.checked) xyLabelsGroup.add(createLabel('p', new THREE.Vector3(x0 + dir2D.x * 2.6, y0 + dir2D.y * 2.6, 0), COLOR_WARM_ORANGE, xyScale));

                // φ label placed on the φ arc
                const phiLabelPos = new THREE.Vector3((params.cylinder_radius + 0.6) * Math.cos(phiRad / 2), (params.cylinder_radius + 0.6) * Math.sin(phiRad / 2), 0);
                if (!chkLabels || chkLabels.checked) xyLabelsGroup.add(createLabel('φ', phiLabelPos, COLOR_PINE_GREEN, xyScale));

                // ψ label on psi arc
                const arcR = 1.5;
                const psiLabelPos = new THREE.Vector3(x0 + arcR * Math.cos(psiRad / 2), y0 + arcR * Math.sin(psiRad / 2), 0);
                if (!chkLabels || chkLabels.checked) xyLabelsGroup.add(createLabel('ψ', psiLabelPos, COLOR_SOFT_RED, xyScale));

                // track label at midpoint
                if (pts2D.length && (!chkLabels || chkLabels.checked)) {
                    const mid = pts2D[Math.floor(pts2D.length / 2)];
                    xyLabelsGroup.add(createLabel('track', new THREE.Vector3(mid.x + 0.12, mid.y + 0.12, 0), COLOR_SOFT_RED, xyScale));
                }
            } catch (e) {
                console.warn('xy labeling failed', e);
            }
        }

        // -------- 构建 2D 线条/箭头的空壳 --------
        let xyTrack, xyPArr, xyPhiArc, xyPsiArc;   // 会随参数更新


        // 动画循环
        function animate() {
            buildXYProjections();   // 参数变化即重绘
            xyRenderer.render(xyScene, xyCam);
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            // also update small window renderer size to match CSS
            updateXYRendererSize();
        });

        // 初始状态
        updateStatus('test');
    </script>

</body>

</html>
